// Замыкания - момент, когда функция имеет доступ
// до переменных из вышестоящего Scope

// function sayHelloTo(name) {
//     const message = 'Hello ' + name
//
//     return function () {
//         console.log('message: ', message)
//     }
// }
//
// const helloToElena = sayHelloTo('Elena')
// const helloToIvan = sayHelloTo('Ivan')
// console.log('helloToElena: ', helloToElena) // тут мы понимаем, что это функция и можем ее вызватьв  след строке
// console.log('helloToElena: ', helloToElena()) // тут мы ее вызываем; функция, которая ничего не возвращает, по умолчанию возращает undefined
// helloToIvan()

// -------------------

// function createFrameworkManager() {
//     const frameworks = ['Angular', 'React']
//
//     return{
//         print: function () {
//             console.log(frameworks)
//         },
//         add: function (fw) {
//             frameworks.push(fw)
//         }
//     }
// }
//
// const manager = createFrameworkManager()
// // console.log(manager)
// // console.log(frameworks) // не доступно
// manager.print()
//
//
// manager.add('Viu')
// manager.print()

// === SetTimeout ===

// const fib = [1, 2, 3, 5, 8, 13]
//
// for (var i = 0; i < fib.length; i++) {
//     setTimeout(function () {
//         console.log(`fib[${i}] = ${fib[i]}`)
//     }, 1500)
// }

// Что происходит:
//     Переменная i, объявленная с помощью var, имеет функциональную область видимости. Это означает, что i будет доступна за пределами цикла.
//     Все функции, созданные с помощью setTimeout, будут ссылаться на одно и то же значение i после завершения цикла.
//     Когда таймер сработает через 1500 мс, i будет равно fib.length, что делает все выводы undefined.

// ---- Первый способ - заменить var на let все начинает работать так как надо, потому что let существует только внутри блочного Scope ----

// for (let i = 0; i < fib.length; i++) {
//     setTimeout(function () {
//         console.log(`fib[${i}] = ${fib[i]}`)
//     }, 1500)
// }

// Что происходит:
//     Переменная i, объявленная с помощью let, имеет блочную область видимости. Это означает, что на каждой итерации цикла создаётся новая переменная i.
//     Каждая функция, созданная с помощью setTimeout, будет захватывать своё собственное значение i в момент создания.


// ---- Второй способ - использовать замыкания ----

// for (var i = 0; i < fib.length; i++) {
//     (function (j) {
//         setTimeout(function () {
//             console.log(`fib[${j}] = ${fib[j]}`)
//         }, 1500)
//     })(i)
// }

// Пошаговый анализ
// Цикл for:
// Вы начинаете с цикла for, где переменная i объявлена с помощью var. Это означает, что i будет иметь функциональную область видимости и будет доступна за пределами цикла.
// На каждой итерации цикла i увеличивается от 0 до fib.length - 1.
// Немедленный вызов функции (IIFE):
// Внутри цикла вы объявляете и немедленно вызываете анонимную функцию:

// (function (j) {
//     // тело функции
// })(i);

// Эта функция принимает один аргумент j, который инициализируется значением i на текущей итерации цикла.
//     При каждом вызове функции j получает текущее значение i из цикла, и это значение сохраняется в области видимости функции.
//     Сохранение значения:
//     Благодаря тому, что значение i передаётся в качестве аргумента j, каждая функция, созданная в setTimeout, будет ссылаться на своё собственное значение j, а не на общее значение i.
//     Это означает, что каждая итерация цикла (и каждый вызов setTimeout) будет иметь своё собственное значение j.
//     setTimeout:
// Внутри IIFE вы устанавливаете таймер с помощью setTimeout, который будет выполнен через 1500 мс.
//     Когда таймер срабатывает, вызывается функция, которая выводит значение fib[j] в консоль.